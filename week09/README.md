本周作业
1.总结几种 socket 粘包的解包方式: fix length/delimiter based/length field based frame decoder。尝试举例其应用
粘包现象：
粘包问题是指当发送两条消息时，比如发送了 ABC 和 DEF，但另一端接收到的却是 ABCD，像这种一次性读取了两条数据的情况就叫做粘包（正常情况应该是一条一条读取的）。
粘包本质：
TCP 是面向连接的传输协议，TCP 传输的数据是以流的形式，而流数据是没有明确的开始结尾边界，所以 TCP 也没办法判断哪一段流属于一个消息。

结合粘包是由流界限难以确定导致的问题，考虑以下几种方式解决：
fix length frame decoder
数据发送方每次发送固定长度的数据(不超过发送缓冲区大小)，数据接收方读取同样固定长度数据(同样不超过接收缓冲区大小)数据流来合成一条消息数据。
适用于数据速率发送稳定、较小的场景，如工业数据采集消息。

delimiter based frame decoder
数据发送方在数据中加入指定分隔符来标记消息边界，数据接收方读到分隔符时进行拼接成一条数据消息。
适用于数据流中存在特殊字符少的消息。

length field based frame decoder
数据发送方在消息头中加入消息长度标识，数据接收方读到消息头中指定长度的数据后来立即拼接成一条数据消息。

2.实现一个从 socket connection 中解码出 goim 协议的解码器。
见goim-decode.go文件